import array.lox;
import bits.lox;
import math.lox;
import tree.lox;

class HuffmanEncoder {

    /* Build Huffman tree for given text. */
    class buildTree(text)
    {
        var i;
        var freqList = array(Array.countDistinct(text));  // array(BinaryTree([char, freq]))
        var firstFree = 0;
        for (i = 0; i < len(text); i=i+1) {
            var wasSeen = false;
            for (var j = 0; j < firstFree; j=j+1) {
                if (text[i] == freqList[j].payload[0]) {
                    freqList[j].payload[1] = freqList[j].payload[1]+1;
                    wasSeen = true;
                }
            }
            if (!wasSeen) {
                freqList[firstFree] = BinaryTree([text[i], 1], nil, nil);
                firstFree = firstFree+1;
            }
        }
        var smalls;
        while (true) {
            smalls = Array.getTwoSmallest(freqList, fun(a, b){
                if (b == nil) return true;
                if (a == nil) return false;
                return a.payload[1] <= b.payload[1];
                }
            );
            if (freqList[smalls[1]] == nil) break;
            var left = freqList[smalls[0]];
            var right = freqList[smalls[1]];
            freqList[smalls[0]] = BinaryTree([nil, left.payload[1]+right.payload[1]], left, right);
            freqList[smalls[1]] = nil;
        }
        return freqList[smalls[0]];
    }

    /* Return binary encoding represented as string of 1s and 0s of the given character.
     * tree BinaryTree: Generated from Huffman.buildTree
     * char: Character to look for
     * encoding: Recursive parameter. Should be "" */
    class encodeCharacter(tree, char, encoding)
    {
        if (tree == nil) return nil;
        if (tree.payload[0] == char) return encoding;
        var leftRecursion = this.encodeCharacter(tree.left, char, encoding+"0");
        if (leftRecursion != nil) return leftRecursion;
        return this.encodeCharacter(tree.right, char, encoding+"1");
    }

    /* Returns string of 1s and 0s representing the Huffman tree.
     * Harnesses the fact that Huffman trees are full. */
    class encodeTree(tree, charWidth)
    {
        if (tree == nil) return "";
        if (tree.left == nil and tree.right == nil) {
            var bitString = BitMagic.padBitString(BitMagic.toBitString(int(tree.payload[0])), charWidth);
            return "1"+bitString;
        }
        return "0" + this.encodeTree(tree.left, charWidth) + this.encodeTree(tree.right, charWidth);
        
    }

    /* Returns the maximum number of bits necessary to represent every character in the text */
    class maxCharWidth(text)
    {
        var max = 0;
        for (var i = 0; i < len(text); i=i+1) {
            var curr = BitMagic.numBits(int(text[i]));
            if (max < curr) max = curr;
        }
        return max;
    }

    /* Returns bit string representing the Huffman encoding of the given text.
     * Format:
     *     charWidth (8-bits) - encodedHuffmanTree (full) - encodedText - 1 - 0* (to pad to byte size)
     */
    class encode(text)
    {
        var huffmanTree = this.buildTree(text);
        var charWidth = this.maxCharWidth(text);
        var encodedBitString = BitMagic.padBitString(BitMagic.toBitString(charWidth), 8);
        encodedBitString = encodedBitString + this.encodeTree(huffmanTree, charWidth);
        for (var i = 0; i < len(text); i=i+1) {
            encodedBitString = encodedBitString + this.encodeCharacter(huffmanTree, text[i], "");
        }
        encodedBitString = encodedBitString+"1";
        while (Math.mod(len(encodedBitString), 8) != 0) encodedBitString = encodedBitString+"0";
        return encodedBitString;
    }
}

class HuffmanDecoder {

    init(bitstring)
    {
        this.bitstring = bitstring;
        this.currentBit = 0;
    }

    buildTree(charWidth, tree)
    {
        this.currentBit = this.currentBit+1;
        if (this.bitstring[this.currentBit-1] == "1") {
            var char = "";
            for (var j = 0; j < charWidth; j=j+1, this.currentBit=this.currentBit+1) {
                char = char+this.bitstring[this.currentBit];
            }
            char = chr(BitMagic.fromBitString(char));
            tree.payload = char;
            return;
        }
        tree.left = BinaryTree(nil, nil, nil);
        tree.right = BinaryTree(nil, nil, nil);
        this.buildTree(charWidth, tree.left);
        this.buildTree(charWidth, tree.right);
    }

    decodeCharacter(tree)
    {
        if (tree.payload != nil) return tree.payload;
        this.currentBit = this.currentBit+1;
        if (this.bitstring[this.currentBit-1] == "0") return this.decodeCharacter(tree.left);
        return this.decodeCharacter(tree.right);
    }

    decode()
    {
        var charWidth = "";
        for (this.currentBit = 0; this.currentBit < 8; this.currentBit=this.currentBit+1) {
            charWidth = charWidth+this.bitstring[this.currentBit];
        }
        charWidth = BitMagic.fromBitString(charWidth);

        var huffmanTree = BinaryTree(nil, nil, nil);
        this.buildTree(charWidth, huffmanTree);

        var lastBit = len(this.bitstring)-1;
        while (this.bitstring[lastBit] != "1") lastBit = lastBit-1;

        var decodedStr = "";
        while (this.currentBit < lastBit) {
            var res = this.decodeCharacter(huffmanTree);
            decodedStr = decodedStr+res;
        }
        return decodedStr;
    }
}

var text = readfile("text");
var encoded = HuffmanEncoder.encode(text);
writefile("encoded", BitMagic.bitstringToText(encoded));
var encodedBitString = "";
var encoded = readfile("encoded");
for (var i = 0; i < len(encoded); i=i+1) {
    encodedBitString = encodedBitString + BitMagic.padBitString(BitMagic.toBitString(int(encoded[i])), 8);
}
print HuffmanDecoder(encodedBitString).decode();
/*
"Hello World!"
            12
        /       \
       5          7
     / \     /         \
   o,2 l,3  3              4
           / \          /    \
         H,1  2        2      2
             /  \     / \    / \
            !,1 d,1 r,1 W,1  ,1 e,1
*/
